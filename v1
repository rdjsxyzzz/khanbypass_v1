// ==UserScript==

// @name Â  Â  Â  Â  Khan Modded with Panel and Auto Resolver Improved v2

// @version Â  Â  Â 1.5.1

// @description Â Automatiza y modifica interacciones en Khan Academy con panel flotante y auto resolver mejorado

// @author Â  Â  Â  rxdrzx_

// @match Â  Â  Â  Â *://*.khanacademy.org/*

// @grant Â  Â  Â  Â none

// ==/UserScript==



// Clave de activaciÃ³n encriptada (base64 de "RSkhanmod")

const ENCODED_KEY = "UlNraGFubW9k";



let loadedPlugins = [];

let isActivated = false;

let autoResolverEnabled = false;



console.clear();

const noop = () => {};

console.warn = console.error = window.debug = noop;



const splashScreen = document.createElement('splashScreen');



class EventEmitter {

Â  constructor() { this.events = {}; }

Â  on(t, e) {

Â  Â  (Array.isArray(t) ? t : [t]).forEach(t => {

Â  Â  Â  (this.events[t] = this.events[t] || []).push(e);

Â  Â  });

Â  }

Â  off(t, e) {

Â  Â  (Array.isArray(t) ? t : [t]).forEach(t => {

Â  Â  Â  this.events[t] && (this.events[t] = this.events[t].filter(h => h !== e));

Â  Â  });

Â  }

Â  emit(t, ...e) {

Â  Â  this.events[t]?.forEach(h => h(...e));

Â  }

Â  once(t, e) {

Â  Â  const s = (...i) => {

Â  Â  Â  e(...i);

Â  Â  Â  this.off(t, s);

Â  Â  };

Â  Â  this.on(t, s);

Â  }

}



const plppdo = new EventEmitter();



// Observer otimizado

new MutationObserver(mutationsList =>

Â  mutationsList.some(m => m.type === 'childList') && plppdo.emit('domChanged')

).observe(document.body, { childList: true, subtree: true });



// ConfiguraciÃ³n global

let config = {

Â  clickInterval: 25000, // ms

Â  videoBypassEnabled: true

};



// Contadores

let stats = {

Â  exercisesCompleted: 0,

Â  videosWatched: 0,

Â  timeSaved: 0

};



let startTime;



// Panel flotante

function createFloatingPanel() {

Â  const panel = document.createElement('div');

Â  panel.id = 'khanModPanel';

Â  panel.style.cssText = `

Â  Â  position: fixed;

Â  Â  top: 10px;

Â  Â  right: 10px;

Â  Â  width: 300px;

Â  Â  background: rgba(0, 0, 0, 0.8);

Â  Â  color: white;

Â  Â  padding: 10px;

Â  Â  border-radius: 8px;

Â  Â  z-index: 10000;

Â  Â  font-family: Arial, sans-serif;

Â  Â  font-size: 12px;

Â  Â  box-shadow: 0 0 10px rgba(0,0,0,0.5);

Â  `;



Â  function updatePanel() {

Â  Â  if (isActivated) {

Â  Â  Â  panel.innerHTML = `

Â  Â  Â  Â  <h3 style="margin: 0 0 10px 0; color: #ff0000;">KHAN MODED</h3>

Â  Â  Â  Â  <p style="margin: 0 0 10px 0;">Estado: Activado</p>

Â  Â  Â  Â  <label>

Â  Â  Â  Â  Â  Intervalo de clics (ms):

Â  Â  Â  Â  Â  <input type="number" id="clickInterval" value="${config.clickInterval}" min="1000" max="60000" style="width: 100%; margin: 5px 0;">

Â  Â  Â  Â  </label>

Â  Â  Â  Â  <label>

Â  Â  Â  Â  Â  <input type="checkbox" id="videoBypass" ${config.videoBypassEnabled ? 'checked' : ''}> Bypass de videos

Â  Â  Â  Â  </label>

Â  Â  Â  Â  <label>

Â  Â  Â  Â  Â  <input type="checkbox" id="autoResolver" ${autoResolverEnabled ? 'checked' : ''}> Auto Resolver Tareas/Unidades

Â  Â  Â  Â  </label>

Â  Â  Â  Â  <div style="margin: 10px 0; border-top: 1px solid #555; padding-top: 10px;">

Â  Â  Â  Â  Â  <strong>EstadÃ­sticas:</strong><br>

Â  Â  Â  Â  Â  Ejercicios: ${stats.exercisesCompleted}<br>

Â  Â  Â  Â  Â  Videos: ${stats.videosWatched}<br>

Â  Â  Â  Â  Â  Tiempo ahorrado: ${Math.floor(stats.timeSaved / 60)}m ${stats.timeSaved % 60}s

Â  Â  Â  Â  </div>

Â  Â  Â  Â  <button id="deactivateBtn" style="width: 100%; margin: 5px 0;">Desactivar</button>

Â  Â  Â  Â  <button id="togglePanel" style="margin-top: 10px; width: 100%;">Minimizar</button>

Â  Â  Â  `;

Â  Â  } else {

Â  Â  Â  panel.innerHTML = `

Â  Â  Â  Â  <h3 style="margin: 0 0 10px 0; color: #ff0000;">KHAN MODED</h3>

Â  Â  Â  Â  <input type="password" id="keyInput" placeholder="Clave de activaciÃ³n" style="width: 100%; margin: 5px 0;">

Â  Â  Â  Â  <button id="activateBtn" style="width: 100%;">Activar</button>

Â  Â  Â  `;

Â  Â  }



Â  Â  // Eventos

Â  Â  if (isActivated) {

Â  Â  Â  const clickIntervalInput = panel.querySelector('#clickInterval');

Â  Â  Â  const videoBypassCheckbox = panel.querySelector('#videoBypass');

Â  Â  Â  const autoResolverCheckbox = panel.querySelector('#autoResolver');

Â  Â  Â  const deactivateBtn = panel.querySelector('#deactivateBtn');

Â  Â  Â  const togglePanelBtn = panel.querySelector('#togglePanel');



Â  Â  Â  if (clickIntervalInput) {

Â  Â  Â  Â  clickIntervalInput.addEventListener('change', (e) => {

Â  Â  Â  Â  Â  config.clickInterval = parseInt(e.target.value);

Â  Â  Â  Â  Â  sendToast(`Intervalo actualizado: ${config.clickInterval}ms`, 2000);

Â  Â  Â  Â  });

Â  Â  Â  }



Â  Â  Â  if (videoBypassCheckbox) {

Â  Â  Â  Â  videoBypassCheckbox.addEventListener('change', (e) => {

Â  Â  Â  Â  Â  config.videoBypassEnabled = e.target.checked;

Â  Â  Â  Â  Â  sendToast(`Bypass de videos: ${config.videoBypassEnabled ? 'Activado' : 'Desactivado'}`, 2000);

Â  Â  Â  Â  });

Â  Â  Â  }



Â  Â  Â  if (autoResolverCheckbox) {

Â  Â  Â  Â  autoResolverCheckbox.addEventListener('change', (e) => {

Â  Â  Â  Â  Â  autoResolverEnabled = e.target.checked;

Â  Â  Â  Â  Â  sendToast(`Auto Resolver: ${autoResolverEnabled ? 'Activado' : 'Desactivado'}`, 2000);

Â  Â  Â  Â  Â  if (autoResolverEnabled) {

Â  Â  Â  Â  Â  Â  startAutoResolver();

Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });

Â  Â  Â  }



Â  Â  Â  if (deactivateBtn) {

Â  Â  Â  Â  deactivateBtn.addEventListener('click', () => {

Â  Â  Â  Â  Â  isActivated = false;

Â  Â  Â  Â  Â  window.khanwareDominates = false;

Â  Â  Â  Â  Â  autoResolverEnabled = false;

Â  Â  Â  Â  Â  stats.timeSaved += Math.floor((Date.now() - startTime) / 1000);

Â  Â  Â  Â  Â  sendToast(`Desactivado. EstadÃ­sticas: Ejercicios ${stats.exercisesCompleted}, Videos ${stats.videosWatched}, Tiempo ${Math.floor(stats.timeSaved / 60)}m ${stats.timeSaved % 60}s`, 5000);

Â  Â  Â  Â  Â  updatePanel();

Â  Â  Â  Â  });

Â  Â  Â  }



Â  Â  Â  if (togglePanelBtn) {

Â  Â  Â  Â  togglePanelBtn.addEventListener('click', () => {

Â  Â  Â  Â  Â  const content = panel.querySelectorAll('*:not(#togglePanel)');

Â  Â  Â  Â  Â  content.forEach(el => el.style.display = el.style.display === 'none' ? 'block' : 'none');

Â  Â  Â  Â  Â  togglePanelBtn.textContent = content[0].style.display === 'none' ? 'Maximizar' : 'Minimizar';

Â  Â  Â  Â  });

Â  Â  Â  }

Â  Â  } else {

Â  Â  Â  const activateBtn = panel.querySelector('#activateBtn');

Â  Â  Â  const keyInput = panel.querySelector('#keyInput');

Â  Â  Â  if (activateBtn && keyInput) {

Â  Â  Â  Â  activateBtn.addEventListener('click', () => {

Â  Â  Â  Â  Â  const key = keyInput.value;

Â  Â  Â  Â  Â  if (key === atob(ENCODED_KEY)) {

Â  Â  Â  Â  Â  Â  isActivated = true;

Â  Â  Â  Â  Â  Â  sendToast("âœ… Clave correcta. Script activado.", 3000);

Â  Â  Â  Â  Â  Â  updatePanel();

Â  Â  Â  Â  Â  Â  setupMain(); // Activar el script despuÃ©s de la activaciÃ³n

Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  sendToast("âŒ Clave incorrecta.", 3000);

Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });

Â  Â  Â  }

Â  Â  }

Â  }



Â  updatePanel();

Â  document.body.appendChild(panel);

}



// Funciones helpers

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

const findAndClickBySelector = selector => document.querySelector(selector)?.click();



function sendToast(text, duration = 5000, gravity = 'bottom') {

Â  Toastify({

Â  Â  text,

Â  Â  duration,

Â  Â  gravity,

Â  Â  position: "center",

Â  Â  stopOnFocus: true,

Â  Â  style: { background: "#000000" }

Â  }).showToast();

}



async function showSplashScreen() {

Â  splashScreen.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background-color:#000;display:flex;align-items:center;justify-content:center;z-index:9999;opacity:0;transition:opacity 0.5s ease;user-select:none;color:white;font-family:MuseoSans,sans-serif;font-size:30px;text-align:center;";

Â  splashScreen.innerHTML = '<span style="color:white;">KHAN Â </span><span style="color:#ff0000;"> MODED</span>';

Â  document.body.appendChild(splashScreen);

Â  setTimeout(() => splashScreen.style.opacity = '1', 10);

}



async function hideSplashScreen() {

Â  splashScreen.style.opacity = '0';

Â  setTimeout(() => splashScreen.remove(), 1000);

}



async function loadScript(url, label) {

Â  const response = await fetch(url);

Â  const script = await response.text();

Â  loadedPlugins.push(label);

Â  eval(script);

}



async function loadCss(url) {

Â  return new Promise(resolve => {

Â  Â  const link = document.createElement('link');

Â  Â  link.rel = 'stylesheet';

Â  Â  link.type = 'text/css';

Â  Â  link.href = url;

Â  Â  link.onload = resolve;

Â  Â  document.head.appendChild(link);

Â  });

}



function setupMain() {

Â  if (!isActivated) return;



Â  startTime = Date.now();



Â  const originalFetch = window.fetch;



Â  window.fetch = async function(input, init) {



Â  Â  let body;

Â  Â  if (input instanceof Request) {

Â  Â  Â  body = await input.clone().text();

Â  Â  } else if (init?.body) {

Â  Â  Â  body = init.body;

Â  Â  }



Â  Â  if (config.videoBypassEnabled && body?.includes('"operationName":"updateUserVideoProgress"')) {

Â  Â  Â  try {

Â  Â  Â  Â  let bodyObj = JSON.parse(body);

Â  Â  Â  Â  if (bodyObj.variables?.input) {

Â  Â  Â  Â  Â  const durationSeconds = bodyObj.variables.input.durationSeconds;

Â  Â  Â  Â  Â  bodyObj.variables.input.secondsWatched = durationSeconds;

Â  Â  Â  Â  Â  bodyObj.variables.input.lastSecondWatched = durationSeconds;

Â  Â  Â  Â  Â  body = JSON.stringify(bodyObj);



Â  Â  Â  Â  Â  if (input instanceof Request) {

Â  Â  Â  Â  Â  Â  input = new Request(input, { body });

Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  init.body = body;

Â  Â  Â  Â  Â  }



Â  Â  Â  Â  Â  stats.videosWatched++;

Â  Â  Â  Â  Â  sendToast("âœ…ï½œBypass injectedÂ¡", 1500);

Â  Â  Â  Â  }

Â  Â  Â  } catch (e) {}

Â  Â  }



Â  Â  const originalResponse = await originalFetch.apply(this, arguments);



Â  Â  try {

Â  Â  Â  const clonedResponse = originalResponse.clone();

Â  Â  Â  const responseBody = await clonedResponse.text();

Â  Â  Â  let responseObj = JSON.parse(responseBody);



Â  Â  Â  if (responseObj?.data?.assessmentItem?.item?.itemData) {

Â  Â  Â  Â  let itemData = JSON.parse(responseObj.data.assessmentItem.item.itemData);



Â  Â  Â  Â  if (itemData.question.content[0] === itemData.question.content[0].toUpperCase()) {

Â  Â  Â  Â  Â  itemData.answerArea = {

Â  Â  Â  Â  Â  Â  calculator: false,

Â  Â  Â  Â  Â  Â  chi2Table: false,

Â  Â  Â  Â  Â  Â  periodicTable: false,

Â  Â  Â  Â  Â  Â  tTable: false,

Â  Â  Â  Â  Â  Â  zTable: false

Â  Â  Â  Â  Â  };



Â  Â  Â  Â  Â  itemData.question.content = "modified by: rxdrzx_ @tk @ig " + `[[â˜ƒ radio 1]]`;

Â  Â  Â  Â  Â  itemData.question.widgets = {

Â  Â  Â  Â  Â  Â  "radio 1": {

Â  Â  Â  Â  Â  Â  Â  type: "radio",

Â  Â  Â  Â  Â  Â  Â  options: {

Â  Â  Â  Â  Â  Â  Â  Â choices: [{ content: "correct âœ…", correct: true },

Â  Â  Â  Â  { content: "incorrect âŒ", correct: false }]

Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  };



Â  Â  Â  Â  Â  responseObj.data.assessmentItem.item.itemData = JSON.stringify(itemData);



Â  Â  Â  Â  Â  return new Response(JSON.stringify(responseObj), {

Â  Â  Â  Â  Â  Â  status: originalResponse.status,

Â  Â  Â  Â  Â  Â  statusText: originalResponse.statusText,

Â  Â  Â  Â  Â  Â  headers: originalResponse.headers

Â  Â  Â  Â  Â  });

Â  Â  Â  Â  }

Â  Â  Â  }

Â  Â  } catch (e) {}



Â  Â  return originalResponse;

Â  };



Â  (async () => {

Â  Â  const selectors = [

Â  Â  Â  `[data-testid="choice-icon__library-choice-icon"]`,

Â  Â  Â  `[data-testid="exercise-check-answer"]`,

Â  Â  Â  `[data-testid="exercise-next-question"]`,

Â  Â  Â  `._1udzurba`,

Â  Â  Â  `._awve9b`

Â  Â  ];



Â  Â  window.khanwareDominates = true;



Â  Â  while (window.khanwareDominates && isActivated) {

Â  Â  Â  for (const selector of selectors) {

Â  Â  Â  Â  findAndClickBySelector(selector);



Â  Â  Â  Â  const element = document.querySelector(`${selector}> div`);

Â  Â  Â  Â  if (element?.innerText === "Mostrar resumo") {

Â  Â  Â  Â  Â  stats.exercisesCompleted++;

Â  Â  Â  Â  Â  sendToast("ðŸŽ‰ï½œExercÃ­cio concluÃ­do!", 3000);

Â  Â  Â  Â  }

Â  Â  Â  }

Â  Â  Â  await delay(config.clickInterval);

Â  Â  }

Â  })();

}



// Auto Resolver: Prioriza tareas incompletas y luego unidades incompletas, reiniciando al finalizar

async function startAutoResolver() {

Â  if (!isActivated || !autoResolverEnabled) return;



Â  while (autoResolverEnabled && isActivated) {

Â  Â  // Priorizar tareas incompletas

Â  Â  // Selector actualizado para detectar tareas incompletas en la tabla "Mis tareas"

Â  Â  let incompleteTasks = Array.from(document.querySelectorAll('table tbody tr'))

Â  Â  Â  .filter(row => {

Â  Â  Â  Â  const statusCell = row.querySelector('td:nth-child(3)');

Â  Â  Â  Â  return statusCell && !statusCell.textContent.toLowerCase().includes('completado');

Â  Â  Â  })

Â  Â  Â  .map(row => row.querySelector('td:nth-child(1) a'))

Â  Â  Â  .filter(a => a !== null);



Â  Â  console.log(`Auto Resolver: Tareas incompletas detectadas: ${incompleteTasks.length}`);



Â  Â  if (incompleteTasks.length > 0) {

Â  Â  Â  for (const task of incompleteTasks) {

Â  Â  Â  Â  task.click();

Â  Â  Â  Â  sendToast("Auto Resolver: Abriendo tarea incompleta...", 2000);

Â  Â  Â  Â  await delay(config.clickInterval + 2000);

Â  Â  Â  }

Â  Â  } else {

Â  Â  Â  // Si no hay tareas incompletas, buscar unidades incompletas

Â  Â  Â  // Selector actualizado para detectar unidades incompletas en "Cursos de la clase"

Â  Â  Â  let incompleteUnits = Array.from(document.querySelectorAll('div[class*="classroom-courses"] a'))

Â  Â  Â  Â  .filter(a => {

Â  Â  Â  Â  Â  const progressText = a.querySelector('span');

Â  Â  Â  Â  Â  return progressText && !progressText.textContent.toLowerCase().includes('dominado');

Â  Â  Â  Â  });



Â  Â  Â  console.log(`Auto Resolver: Unidades incompletas detectadas: ${incompleteUnits.length}`);



Â  Â  Â  if (incompleteUnits.length > 0) {

Â  Â  Â  Â  for (const unit of incompleteUnits) {

Â  Â  Â  Â  Â  unit.click();

Â  Â  Â  Â  Â  sendToast("Auto Resolver: Abriendo unidad incompleta...", 2000);

Â  Â  Â  Â  Â  await delay(config.clickInterval + 2000);

Â  Â  Â  Â  }

Â  Â  Â  } else {

Â  Â  Â  Â  // Si no hay tareas ni unidades incompletas, esperar y reintentar sin recargar

Â  Â  Â  Â  sendToast("Auto Resolver: No quedan tareas ni unidades incompletas. Reintentando en 30s...", 3000);

Â  Â  Â  Â  await delay(30000);

Â  Â  Â  }

Â  Â  }

Â  }

}
